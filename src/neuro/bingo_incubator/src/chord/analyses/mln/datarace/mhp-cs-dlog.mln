// domains
*dom_AS(as_dom)
*dom_I(i_dom)
*dom_M(m_dom)
*dom_P(p_dom)
*dom_C(c_dom)
// input predicates
*PI(p_dom, i_dom)
*CICM(c_dom, i_dom, c_dom, m_dom)
*threadStartI(i_dom)
*MPhead(m_dom, p_dom)
*threadACM(as_dom, c_dom, m_dom)
*PP(p_dom, p_dom)
*threadCICM(c_dom, i_dom, c_dom, m_dom)
*MPtail(m_dom, p_dom)

// non-input predicates, which can appear on the lhs of each rule
SummEdge_cs(c_dom, p_dom, as_dom, as_dom, as_dom)
simplePT_cs(c_dom, p_dom, c_dom, p_dom)
PathEdge_cs(c_dom, p_dom, as_dom, as_dom, as_dom)
simplePM_cs(c_dom, p_dom, c_dom, m_dom)
threadAC(as_dom, c_dom)
simplePH_cs(c_dom, p_dom, c_dom, p_dom)
threadPH_cs(c_dom, p_dom, c_dom, p_dom)
mhp_cs(c_dom, p_dom, as_dom, as_dom)
threadACH(as_dom, c_dom, p_dom)
threadPM_cs(c_dom, p_dom, c_dom)

// hard rules converted from dlog into soft rules
1 CICM(c,i,d,m), PI(p,i), !threadStartI(i) => simplePM_cs(c,p,d,m)
1 simplePM_cs(c,p,d,m), MPhead(m,h) => simplePH_cs(c,p,d,h)
1 simplePM_cs(c,p,d,m), MPtail(m,t) => simplePT_cs(c,p,d,t)
1 threadCICM(c,i,d,m), PI(p,i) => threadPM_cs(c,p,d)
1 threadCICM(c,i,d,m), PI(p,i), MPhead(m,h) => threadPH_cs(c,p,d,h)
1 threadACM(t,c,m), m!=0 => threadAC(t,c)
1 threadACM(t,c,m), MPhead(m,h), m!=0 => threadACH(t,c,h)
PathEdge_cs(0,0,1,0,0).
1 PathEdge_cs(c,p,t,t1,t2), PP(p,q) => PathEdge_cs(c,q,t,t1,t2)
1 simplePH_cs(c,p,d,q), PathEdge_cs(c,p,t,t3,t2), t1=t2 => PathEdge_cs(d,q,t,t1,t2)
1 simplePT_cs(c,p,d,q), PathEdge_cs(d,q,t,t1,t2) => SummEdge_cs(c,p,t,t1,t2)
1 SummEdge_cs(c,p,t,t2,t3), PathEdge_cs(c,p,t,t1,t2), PP(p,r) => PathEdge_cs(c,r,t,t1,t3)
1 threadPM_cs(c,p,d), PathEdge_cs(c,p,t,t1,t3), PP(p,r), threadAC(t2,d) => PathEdge_cs(c,r,t,t1,t2)
1 threadPH_cs(c,p,d,h), PathEdge_cs(c,p,y,t1,t2), threadAC(x,d), z=y => PathEdge_cs(d,h,x,y,z)
1 threadPH_cs(c,p,d,h), PathEdge_cs(c,p,t1,t2,y), threadAC(x,d), z=y => PathEdge_cs(d,h,x,y,z)
1 threadPM_cs(c,p,d), PathEdge_cs(c,p,t1,t2,x), threadACH(x,e,h1), threadAC(y,d), z=y => PathEdge_cs(e,h1,x,y,z)
1 PathEdge_cs(c,p,t1,t3,t2), t1!=0, t2!=0 => mhp_cs(c,p,t1,t2)
