# Author: Xin Zhang
# name=typestate-pred-dlog

.include "I.dom"
.include "M.dom"
.include "P.dom"
.include "V.dom"
.include "Z.dom"
.include "H.dom"
.include "MS.dom"
.include "K.dom"
.include "F.dom"

.bddvarorder P0xP1_I0xM0_V0xV1xV2_H0xH1xH2_F0_Z0xZ1_MS0xMS1xMS2xMS3_K0xK1

###
# Relations
###

PP(p:P,q:P) input
PI(p:P,i:I) input
IM(i:I,m:M) input
PobjValAsgnInst(p:P,v:V,h:H) input
PobjVarAsgnInst(p:P,v:V,u:V) input
MPhead(m:M,p:P) input
rootM(m:M) input
PobjNullAsgnInst(p:P,v:V) input
PgetInstFldInst(p:P,v:V,u:V,f:F) input
PgetStatFldInst(p:P,v:V,f:F) input
MmethArg(m:M0,n:Z0,v:V0) input
IinvkArg(i:I0,n:Z0,v:V1) input
MP(m:M,p:P) input
MPtail(m:M,p:P) input
IinvkRet(i:I0,n:Z0,v:V0) input
MmethRet(m:M0,n:Z0,v:V1) input
MZfirst(m:M,z:Z) input
MZlast(m:M,z:Z) input
MZZ(m:M,z:Z,z:Z) input
MK(m:M,k:K) input
gen(ms1:MS,v:V,ms2:MS) input 		#ms2 = ms1+v
kill(ms1:MS,v:V,ms2:MS) input 		#ms2 = ms1-v
contain(v:V,ms:MS) input
virtIM(i:I,m:M) input
specIM(i:I,m:M) input
PobjRetInst(p:P,v:V) input
checkExcludedH(h:H) input
checkExcludedI(i:I) input
VH(v:V, h:H) input
reachableM(m:M) input
trackedH(h:H) input

path(p:P,h1:H,ms1:MS,h2:H,ms2:MS,k:K) output #k=0 implies that return var is in must set
summary(m:M,h:H,ms1:MS,h2:H,k:K) output
pathArg(p:P,z:Z,m:M,ms1:MS,ms2:MS) output
#VVMZ(v:V,u:V,m:M,z:Z)
#VVMZRet(v:V,u:V,m:M)
PInvkInst(p:P,m:M,v:V,u:V,z:Z)
PInvkRetInst(p:P,m:M,v:V,u:V)
PInvkRetInstFilter(p:P,m:M)
PInvkRetInstNotFilter(p:P,m:M)
nonRelevantP(p:P) output
relevantP(p:P) output
pathArgInit(p:P,ms1:MS,h:H)
pathArgLast(p:P,m:M,ms1:MS,ms2:MS)
PInvkSkip(p:P)
IMFilter(i:I)

# The concrete meaning is: At program p, given a concrete object allocated at h, if the must-alias
# set of it ms, then v may not point to it.
NotVH(p:P, h:H, ms:MS, v:V) output
NotVHArg(p:P, z:Z, m:M, ms:MS, v:V)
NotVHArgInit(p:P, h:H, ms:MS, v:V)
NotVHArgLast(p:P, m:M, ms:MS, v:V)

unprovenQuery(p:P,h:H) output

errorPath(p:P,h:H,ms:MS,v:V) output


###
# Constraints
###
## Assuming throughout that no instruction will be processed
## after a return instruction for any path edge.

#VVMZ(v,u,m,z) :- IinvkArg(i,z,u), IM(i,m),  MmethArg(m,z,v).
#VVMZRet(v,u,m) :- IinvkRet(i,z,v), IM(i,m),  MmethRet(m,z,u).
PInvkInst(p,m,v,u,z) :- PI(p,i), IM(i,m), IinvkArg(i,z,u), MmethArg(m,z,v).
PInvkRetInst(p,m,v,u) :- PI(p,i), IM(i,m), IinvkRet(i,z,v), MmethRet(m,z,u).
PInvkRetInstFilter(p,m) :- PInvkRetInst(p,m,_,_).
PInvkRetInstNotFilter(p,m) :- !PInvkRetInstFilter(p,m).
IMFilter(i) :- IM(i,_).
PInvkSkip(p) :- PI(p,i), !IMFilter(i).

#path(p,0,0,0,0,0) :- rootM(m), MPhead(m,p).
#path(p,0,0,0,0,0) :- path(q,0,0,0,0,0,0), PP(q,p).
#path(p,0,0,0,0,0) :- reachableM(m), MP(m,p).
#path(p,0,0,0,0,0) :- reachableM(m), MPtail(m,p).

path(p,0,0,0,0,0) :- reachableM(m), MPhead(m,p).

NotVH(p,0,0,_) :- reachableM(m), MPhead(m,p).

### v = new h
path(p,0,0,h,ms,0) :- PobjValAsgnInst(p,v,h), PP(q,p), path(q,0,0,0,0,0), gen(0,v,ms), trackedH(h).split
NotVH(p, h, ms, u) :- PobjValAsgnInst(p,v,h), PP(q,p), path(q,0,0,0,0,0), gen(0,v,ms), trackedH(h), VH(u,h), u!=v.split

path(p,h1,ms1,h2,ms3,0) :- PobjValAsgnInst(p,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3).split
NotVH(p, h2, ms3, v) :- PobjValAsgnInst(p,v,_), PP(q,p), path(q,_,_,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3), VH(v,h2).split
NotVH(p, h2, ms3, u) :- PobjValAsgnInst(p,v,_), PP(q,p), path(q,_,_,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3), VH(u,h2), NotVH(q, h2, ms2, u).split

path(p,h1,ms1,h2,ms2,0) :- PobjValAsgnInst(p,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(v,ms2).split
NotVH(p, h2, ms2, u) :- PobjValAsgnInst(p,v,_), PP(q,p), path(q,_,_,h2,ms2,0), !contain(v,ms2), VH(u,h2),NotVH(q, h2, ms2, u).split


### v = u
path(p,h1,ms1,h2,ms3,0) :- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(u,ms2), contain(v,ms2), kill(ms2,v,ms3).split
NotVH(p, h2, ms3, v) :- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,_,_,h2,ms2,0), !contain(u,ms2), contain(v,ms2), kill(ms2,v,ms3), VH(v,h2).split
NotVH(p, h2, ms3, z) :- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,_,_,h2,ms2,0), !contain(u,ms2), contain(v,ms2), kill(ms2,v,ms3), NotVH(p,h2,ms2,z), VH(z,h2), z!=v.split

path(p,h1,ms1,h2,ms2,0) :- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(u,ms2), !contain(v,ms2).split
NotVH(p,h2,ms2,z) :- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,_,_,h2,ms2,0), !contain(u,ms2), !contain(v,ms2), NotVH(q,h2,ms2,z), VH(z,h2).split

path(p,h1,ms1,h2,ms3,0) :- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,h1,ms1,h2,ms2,0), contain(u,ms2), gen(ms2,v,ms3).split
NotVH(p,h2,ms3,z) :- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,_,_,h2,ms2,0), contain(u,ms2), gen(ms2,v,ms3), NotVH(q,h2,ms2,z), VH(z,h2), z!=v.split

### v = null
path(p,h1,ms1,h2,ms3,0) :- PobjNullAsgnInst(p,v), PP(q,p), path(q,h1,ms1,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3).split
NotVH(p,h2,ms3,v) :- PobjNullAsgnInst(p,v), PP(q,p), path(q,_,_,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3), VH(v,h2).split
NotVH(p,h2,ms3,z) :- PobjNullAsgnInst(p,v), PP(q,p), path(q,_,_,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3), NotVH(q,h2,ms2,z), VH(z,h2).split

path(p,h1,ms1,h2,ms2,0) :- PobjNullAsgnInst(p,v), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(v,ms2).split
NotVH(p,h2,ms2,z) :- PobjNullAsgnInst(p,v), PP(q,p), path(q,_,_,h2,ms2,0), !contain(v,ms2),NotVH(q,h2,ms2,z), VH(z,h2).split

### v = u.f
path(p,h1,ms1,h2,ms3,0) :- PgetInstFldInst(p,v,_,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3).split
NotVH(p,h2,ms3,v) :- PgetInstFldInst(p,v,_,_), PP(q,p), path(q,_,_,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3), VH(v,h2).split
NotVH(p,h2,ms3,z) :- PgetInstFldInst(p,v,_,_), PP(q,p), path(q,_,_,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3), NotVH(q,h2,ms2,z), VH(z,h2).split

path(p,h1,ms1,h2,ms2,0) :- PgetInstFldInst(p,v,_,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(v,ms2).split
NotVH(p,h2,ms2,z) :- PgetInstFldInst(p,v,_,_), PP(q,p), path(q,_,_,h2,ms2,0), !contain(v,ms2),NotVH(q,h2,ms2,z), VH(z,h2).split

### v = f
path(p,h1,ms1,h2,ms3,0) :- PgetStatFldInst(p,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3).split
NotVH(p,h2,ms3,v) :- PgetStatFldInst(p,v,_), PP(q,p), path(q,_,_,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3), VH(v,h2).split
NotVH(p,h2,ms3,z) :- PgetStatFldInst(p,v,_), PP(q,p), path(q,_,_,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3), NotVH(q,h2,ms2,z), VH(z,h2).split

path(p,h1,ms1,h2,ms2,0) :- PgetStatFldInst(p,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(v,ms2).split
NotVH(p,h2,ms2,z) :- PgetStatFldInst(p,v,_), PP(q,p), path(q,_,_,h2,ms2,0), !contain(v,ms2),NotVH(q,h2,ms2,z), VH(z,h2).split


### Method Call
pathArgInit(q,ms1,h1) :- PInvkInst(p,m,_,_,z), MZfirst(m,z), PP(q,p), path(q,_,_,h1,ms1,_).split
NotVHArgInit(q, h1, ms1, v) :- PInvkInst(p,m,_,_,z), MZfirst(m,z), PP(q,p), path(q,_,_,h1,ms1,_), NotVH(q, h1, ms1, v), VH(v,h1).split

pathArg(q,z,m,ms2,ms3) :- PInvkInst(p,m,v,u,z), PP(q,p), MZfirst(m,z), path(q,_,_,_,ms2,_), contain(u,ms2), \
									gen(0,v,ms3).split
NotVHArg(q,z,m,ms3,w) :- PInvkInst(p,m,v,u,z), PP(q,p), MZfirst(m,z), path(q,_,_,h,ms2,_), contain(u,ms2), \
									gen(0,v,ms3), NotVH(q,h,ms2,w), w!=v.split

pathArg(q,z,m,ms2,0) :- PInvkInst(p,m,_,u,z), PP(q,p), MZfirst(m,z), path(q,_,_,_,ms2,_), !contain(u,ms2).split
NotVHArg(q,z,m,ms2,w) :- PInvkInst(p,m,_,u,z), PP(q,p), MZfirst(m,z), path(q,_,_,h,ms2,_), !contain(u,ms2), NotVH(q,h,ms2,w).split

pathArg(q,z2,m,ms2,ms4) :- PInvkInst(p,m,v,u,z2), PP(q,p), MZZ(m,z1,z2), pathArg(q,z1,m,ms2,ms3), \
								 	 contain(u,ms2), gen(ms3,v,ms4).split
NotVHArg(q,z2,m,ms4,w) :- PInvkInst(p,m,v,u,z2), PP(q,p), MZZ(m,z1,z2), pathArg(q,z1,m,ms2,ms3), \
								 	 contain(u,ms2), gen(ms3,v,ms4), NotVHArg(q,z1,m,ms3,w), v!=w.split

pathArg(q,z2,m,ms2,ms3) :- PInvkInst(p,m,_,u,z2), PP(q,p), MZZ(m,z1,z2), pathArg(q,z1,m,ms2,ms3), \
								 	 !contain(u,ms2).split
NotVHArg(q,z2,m,ms3,w) :- PInvkInst(p,m,_,u,z2), PP(q,p), MZZ(m,z1,z2), pathArg(q,z1,m,ms2,ms3), \
								 	 !contain(u,ms2), NotVHArg(q,z1,m,ms3,w).split


pathArgLast(q,m,ms1,ms2) :- pathArg(q,z,m,ms1,ms2), MZlast(m,z).
NotVHArgLast(q,m,ms2,w) :- pathArg(q,z,m,_,ms2), MZlast(m,z), NotVHArg(q,z,m,ms2,w).

path(p,h1,ms2,h2,ms3,0) :- pathArgLast(q,m,ms1,ms2), pathArgInit(q,ms1,h1), MPhead(m,p), ms2=ms3, h1=h2.split
NotVH(p,h2,ms3,w) :- pathArgLast(q,m,ms1,ms2), pathArgInit(q,ms1,h1), MPhead(m,p),NotVHArgLast(q,m,ms2,w), ms2=ms3, h1=h2.split


# To handle corner case of static method with no reference parameters
pathArgInit(q,ms1,h1) :- PI(p,i), IM(i,m), PP(q,p), MK(m,k), k=0, path(q,_,_,h1,ms1,_).split
NotVHArgInit(q,h1,ms1, w) :- PI(p,i), IM(i,m), PP(q,p), MK(m,k), k=0, path(q,_,_,h1,ms1,_), NotVH(q,h1,ms1,w), VH(w,h1).split

pathArgLast(q,m,ms1,0) :- PI(p,i), IM(i,m), PP(q,p), MK(m,k), k=0, path(q,_,_,_,ms1,_).split
NotVHArgLast(q,m,ms1,w) :- PI(p,i), IM(i,m), PP(q,p), MK(m,k), k=0, path(q,_,_,h,ms1,_), NotVH(q,h,ms1,w).split

#path(p,h1,0,h2,0,0,0) :- PI(p,i), IM(i,m), PP(q,p), MK(m,k), k=0, path(q,_,_,h1,_,_), MPhead(m,p), h1=h2.split

# To handle corner case of invoke instruction with no target method
path(p,h1,ms2,h2,ms3,0) :- PInvkSkip(p), PP(q,p), path(q,h1,ms2,h2,ms3,0).split
NotVH(p,h2,ms3,w) :- PInvkSkip(p), PP(q,p), path(q,_,_,h2,ms3,0), NotVH(q,h2,ms3,w), VH(w,h2).split

#Applying Summary Edge
path(p,h1,ms1,h3,ms5,0) :- PInvkRetInst(p,m,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), pathArgLast(q,m,ms2,ms3),  \
							 summary(m,h2,ms3,h3,0), contain(v,ms2), kill(ms2,v,ms5).split
NotVH(p,h3,ms5,v) :- PInvkRetInst(p,m,v,_), PP(q,p), path(q,_,_,h2,ms2,0), pathArgLast(q,m,ms2,ms3),  \
							 summary(m,h2,ms3,h3,0), contain(v,ms2), kill(ms2,v,ms5), VH(v,h3).split
NotVH(p,h3,ms5,w) :- PInvkRetInst(p,m,v,_), PP(q,p), path(q,_,_,h2,ms2,0), pathArgLast(q,m,ms2,ms3),  \
							 summary(m,h2,ms3,h3,0), contain(v,ms2), kill(ms2,v,ms5), NotVH(q,h2,ms2,w), VH(w,h3).split

path(p,h1,ms1,h3,ms2,0) :- PInvkRetInst(p,m,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), pathArgLast(q,m,ms2,ms3), \
							 summary(m,h2,ms3,h3,0), !contain(v,ms2).split
NotVH(p,h3,ms2,w) :- PInvkRetInst(p,m,v,_), PP(q,p), path(q,_,_,h2,ms2,0), pathArgLast(q,m,ms2,ms3), \
						 summary(m,h2,ms3,h3,0), !contain(v,ms2), NotVH(q,h2,ms2,w), VH(w,h3).split
						 
path(p,h1,ms1,h3,ms5,0) :- PInvkRetInst(p,m,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), pathArgLast(q,m,ms2,ms3), \
							 summary(m,h2,ms3,h3,1), gen(ms2,v,ms5).split
NotVH(p,h3,ms5,w) :- PInvkRetInst(p,m,v,_), PP(q,p), path(q,_,_,h2,ms2,0), pathArgLast(q,m,ms2,ms3), \
							 summary(m,h2,ms3,h3,1), gen(ms2,v,ms5), NotVH(q,h2,ms2,w), VH(w,h3), w!=v.split
						
# To handle corner case of invoke instruction with no return value or with no var capturing the returned value;
# such instructions are not captured by PInvkRetInst
path(p,h1,ms1,h3,ms2,0) :- PI(p,i), IM(i,m), PInvkRetInstNotFilter(p,m), PP(q,p), path(q,h1,ms1,h2,ms2,0), pathArgLast(q,m,ms2,ms3), \
							 summary(m,h2,ms3,h3,_).split
NotVH(p,h3,ms2,w) :- PI(p,i), IM(i,m), PInvkRetInstNotFilter(p,m), PP(q,p), path(q,_,_,h2,ms2,0), pathArgLast(q,m,ms2,ms3), \
							 summary(m,h2,ms3,h3,_), NotVH(q,h2,ms2,w), VH(w,h3).split

### Method Return
path(p,h1,ms1,h2,ms2,1) :- PobjRetInst(p,v), PP(q,p), path(q,h1,ms1,h2,ms2,0), contain(v,ms2).split
path(p,h1,ms1,h2,ms2,0) :- PobjRetInst(p,v), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(v,ms2), NotVH(q,h2,ms2,v).split

#path(p,h1,ms1,h2,ms2,r,k) :- path(q,h1,ms1,h2,ms2,r,k), PP(q,p), MPtail(m,p). #Handled by nonRelevantP
summary(m,h1,ms1,h2,k) :- MPtail(m,p), path(p,h1,ms1,h2,_,k).split

### All remaining instructions
relevantP(p) :- PobjValAsgnInst(p,_,_).
relevantP(p) :- PobjVarAsgnInst(p,_,_).
relevantP(p) :- PobjNullAsgnInst(p,_).
relevantP(p) :- PgetInstFldInst(p,_,_,_).
relevantP(p) :- PgetStatFldInst(p,_,_).
relevantP(p) :- PI(p,_).
relevantP(p) :- PobjRetInst(p,_).
relevantP(p) :- MPhead(_,p).

#nonRelevantP(p) :- PP(_,p), !PobjValAsgnInst(p,_,_), !PobjVarAsgnInst(p,_,_), !PobjNullAsgnInst(p,_), !PgetInstFldInst(p,_,_,_), \
#				   !PgetStatFldInst(p,_,_), !PI(p,_), !PobjRetInst(p,_).split
nonRelevantP(p) :- PP(_,p), !relevantP(p).
path(p,h1,ms1,h2,ms2,k) :- nonRelevantP(p), PP(q,p), path(q,h1,ms1,h2,ms2,k).split 
NotVH(p,h2,ms2,w) :- nonRelevantP(p), PP(q,p), path(q,_,_,h2,ms2,_), NotVH(q,h2,ms2,w), VH(w,h2).split 


### Query
unprovenQuery(q,h) :- PI(q,i), virtIM(i,_), PP(p,q), path(p,_,_,h,ms,_), IinvkArg(i,0,v), VH(v,h), !contain(v,ms), NotVH(p,h,ms,v), !checkExcludedI(i).split
#unprovenQuery(q,h) :- PI(q,i), specIM(i,_), PP(p,q), path(p,_,_,h,ms,_), IinvkArg(i,0,v), VH(v,h), !contain(v,ms), !checkExcludedI(i).split

errorPath(p,h,ms,v) :- path(p,_,_,h,ms,_), VH(v,h), !NotVH(p,h,ms,v), !contain(v,ms).