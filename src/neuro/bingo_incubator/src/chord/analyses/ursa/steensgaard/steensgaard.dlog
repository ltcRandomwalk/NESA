# Steensgaard with precomputed callgraph analysis. It is flow,context,field-insensitive

# Author: Mayur Naik (mhn@cs.stanford.edu)
# name=steensgaard-dlog

.include "T.dom"
.include "F.dom"
.include "M.dom"
.include "I.dom"
.include "H.dom"
.include "V.dom"
.include "Z.dom"

.bddvarorder I0xM0xM1_T0_V0xV1_T1_H0_F0_H1_Z0

###
# Relations
###

HT(h:H0,t:T1) input
MmethArg(m:M0,n:Z0,v:V0) input
MmethRet(m:M0,n:Z0,v:V1) input
IinvkArg0(i:I0,v:V1) input
IinvkArg(i:I0,n:Z0,v:V1) input
IinvkRet(i:I0,n:Z0,v:V0) input
MI(m:M,i:I) input
IM(i:I,m:M) input
HFH(h0:H0,f0:F0,h1:H1) input # used to handle reflection
VH(v0:V0,h0:H0) input # for reflection
reachableM(m:M) input
reachableI(i:I) input
VHfilter(v:V,h:H) input

MobjValAsgnInst(m:M0,l:V0,h:H0) input
MobjVarAsgnInst(m:M0,l:V0,r:V1) input
MgetInstFldInst(m:M0,l:V0,b:V1,f:F0) input
MputInstFldInst(m:M0,b:V0,f:F0,r:V1) input
MgetStatFldInst(m:M0,l:V0,f:F0) input
MputStatFldInst(m:M0,f:F0,r:V) input

clsForNameIT(i:I0,t:T0) input
objNewInstIH(i:I0,h:H0) input
objNewInstIM(i:I0,m:M0) input
conNewInstIH(i:I0,h:H0) input
conNewInstIM(i:I0,m:M0) input
aryNewInstIH(i:I0,h:H0) input

alloc(l:V,h:H) 
move(l:V,r:V) 
sload(l:V,b:V) 
sstore(b:V,r:V) 
loadGlobal(l:V,f:F) 
storeGlobal(f:F,r:V) 

sHH(h0:H0,h1:H1) output
sVH(v:V,h:H) output
sFH(f0:F0,h0:H0) output

###
# Constraints
###

alloc(l,h)   :- reachableM(m), MobjValAsgnInst(m,l,h).

### Reflections, not really allocations. But since there are no source variables, treat as if they're allocations.
alloc(v,h)  :- reachableI(i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), VHfilter(v,h).
alloc(v,h)  :- reachableI(i), objNewInstIH(i,h), IinvkRet(i,0,v), VHfilter(v,h).
alloc(v,h2) :- reachableI(i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), VH(u,h), HFH(h,0,h2), VHfilter(v,h2).
alloc(v,h)  :- reachableI(i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), VHfilter(v,h).
alloc(v,h)  :- reachableI(i), conNewInstIH(i,h), IinvkRet(i,0,v), VHfilter(v,h).
alloc(v,h)  :- reachableI(i), aryNewInstIH(i,h), IinvkRet(i,0,v), VHfilter(v,h).

move(l,r)   :- reachableM(m), MobjVarAsgnInst(m,l,r).
move(v,u) :- reachableI(i), IinvkArg(i,z,u), IM(i,m), MmethArg(m,z,v).
move(u,v) :- reachableI(i), IinvkRet(i,z,u), IM(i,m), MmethRet(m,z,v).

sload(l,b) :- reachableM(m), MgetInstFldInst(m,l,b,_).
sstore(b,r) :- reachableM(m), MputInstFldInst(m,b,_,r).
loadGlobal(l,f)   :- reachableM(m), MgetStatFldInst(m,l,f).
storeGlobal(f,r)   :- reachableM(m), MputStatFldInst(m,f,r).

# alloc(l,h) -> pts(l) = pts(l) \cup {h}
sVH(v,h) :- alloc(v,h).

# move(l,r) -> pts(l) = pts(r) = pts(l) \cup pts(r)
sVH(l,h) :- move(l,r), sVH(r,h).
sVH(r,h) :- move(l,r), sVH(l,h).

# Globals
sVH(v,h) :- loadGlobal(v,f), sFH(f,h).
sFH(f,h) :- loadGlobal(v,f), sVH(v,h).

sVH(v,h) :- storeGlobal(f,v), sFH(f,h).
sFH(f,h) :- storeGlobal(f,v), sVH(v,h).

# field accesses
sVH(l,h) :- sload(l,b), sVH(b,h1), sHH(h1,h).
sHH(h1,h2) :- sload(l,b), sVH(l,h2), sVH(b,h1).

sVH(r,h) :- sstore(b,r), sVH(b,h1), sHH(h1,h).
sHH(h1,h2) :- sstore(b,r), sVH(r,h2), sVH(b,h1).
